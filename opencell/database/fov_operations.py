import json
import logging
import pandas as pd

from opencell.database import models, utils, metadata_operations

logger = logging.getLogger(__name__)


def insert_microscopy_dataset(session, metadata_row, root_directory, update=False):
    '''
    metadata_row : a row of metadata as a pd.Series that describes one microscopy dataset;
        must have columns 'pml_id' and 'date' (all other columns are dumped in a JSON column)
    root_directory : identifies the root directory in which the dataset appears in ESS;
        either 'plate_microscopy' or 'raw_pipeline_microscopy'
    '''
    pml_id = metadata_row.pml_id
    dataset = (
        session.query(models.MicroscopyDataset)
        .filter(models.MicroscopyDataset.pml_id == pml_id)
        .one_or_none()
    )
    if dataset:
        if update:
            logger.warning('Updating existing entry for %s' % pml_id)
        else:
            logger.warning('Microscopy dataset %s already exists and will not be updated' % pml_id)
            return
    else:
        dataset = models.MicroscopyDataset(pml_id=pml_id)
        logger.info('Inserting new microscopy dataset %s' % pml_id)

    dataset.date = metadata_row.date
    dataset.root_directory = root_directory
    dataset.raw_metadata = json.loads(metadata_row.to_json())
    utils.add_and_commit(session, dataset)


def insert_microscopy_fovs(session, fov_metadata):
    '''
    Insert all FOVs from a single raw-pipeline-microscopy dataset
    fov_metadata : pd.Dataframe of the 'fov-metadata.csv' file from a PML directory
    '''
    grouped = fov_metadata.groupby(['plate_id', 'pipeline_well_id', 'sort_count'])
    for group in grouped.groups:
        plate_id, well_id, sort_count = group
        line_ops = metadata_operations.PolyclonalLineOperations.from_plate_well(
            session, plate_id, well_id, sort_count
        )
        if not line_ops:
            logger.warning('Cannot insert FOVs for %s because no cell line exists' % (group,))
            continue
        line_ops.insert_microscopy_fovs(session, grouped.get_group(group))


def get_unprocessed_fovs(session, result_kind):
    '''
    Retrieve all FOV instances without any results of the specified kind
    in the MicroscopyFOVResult table
    '''
    query = '''
        select fov.*, res.kind as kind from microscopy_fov fov
        left join (select * from microscopy_fov_result where kind = '%s') res
        on fov.id = res.fov_id
        where kind is null;
    '''
    d = pd.read_sql(query % result_kind, session.get_bind())
    unprocessed_fovs = (
        session.query(models.MicroscopyFOV)
        .filter(models.MicroscopyFOV.id.in_(list(d.id)))
        .all()
    )
    return unprocessed_fovs


class MicroscopyFOVOperations:
    '''
    Methods to insert metadata associated with, or 'children' of, microscopy FOVs

    FOV-associated metadata includes the raw tiff metadata, FOV features, and thumbnails,
    FOV 'children' include the ROIs cropped from each FOV

    NOTE: instances of this class cannot be associated with instances of models.MicroscopyFOV
    (in the way that, for example, PolyclonalLineOperations instances
    are associated with instances of models.CellLine)
    because they may be passed to dask.delayed-wrapped methods

    '''

    def __init__(self, fov_id, errors):
        '''
        errors : kwarg passed to add_and_commit; either 'raise' or 'warn'
        '''
        self.fov_id = fov_id
        self.errors = errors


    def insert_nothing(self, session, result):
        '''
        Placeholder method with the same signature as all of the `insert_*` methods
        '''
        return


    def insert_raw_tiff_metadata(self, session, result):
        '''
        Insert the raw tiff metadata and raw TIFF processing events
        generated by FOVProcessor.process_raw_tiff

        Parameters
        ----------
        result : dict with 'metadata' and 'events' keys
            (this should be the output of FOVProcessor.process_raw_tiff)
        '''

        result = utils.to_jsonable(result)
        metadata = result.get('metadata')
        events = result.get('events')

        row = models.MicroscopyFOVResult(
            fov_id=self.fov_id, kind='raw-tiff-metadata', data=metadata
        )
        utils.add_and_commit(session, row, errors=self.errors)

        if len(events):
            row = models.MicroscopyFOVResult(
                fov_id=self.fov_id, kind='raw-tiff-processing-events', data=events
            )
            utils.add_and_commit(session, row, errors=self.errors)


    def insert_fov_features(self, session, result):
        '''
        Insert FOV features
        result : dict returned by FOVProcessor.calculate_fov_features
        '''
        result = utils.to_jsonable(result)
        row = models.MicroscopyFOVResult(
            fov_id=self.fov_id, kind='fov-features', data=result
        )
        utils.add_and_commit(session, row, errors=self.errors)


    def insert_fov_thumbnails(self, session, result):
        '''
        Insert the color ('rgb') thumbnail for the FOV
        result : dict returned by FOVProcessor.generate_fov_thumbnails
        '''
        result = utils.to_jsonable(result)
        thumbnail = models.MicroscopyFOVThumbnail(
            fov_id=self.fov_id,
            size=result['size'],
            data=result['encoded_thumbnails']['rgb']
        )
        utils.add_and_commit(session, thumbnail, errors=self.errors)


    def insert_roi_thumbnails(self, session, result):
        '''
        Insert the color ('rgb') thumbnail for an ROI from the FOV
        result : dict returned by FOVProcessor.generate_roi_thumbnails
        '''
        # if there's no result, we assume the FOV did not an ROI
        if result is None:
            return

        result = utils.to_jsonable(result)
        thumbnail = models.MicroscopyFOVROIThumbnail(
            roi_id=result['roi_id'],
            size=result['size'],
            data=result['encoded_thumbnails']['rgb']
        )
        utils.add_and_commit(session, thumbnail, errors=self.errors)


    def insert_z_profiles(self, session, result):
        '''
        Insert z-profiles
        result : dict returned by FOVProcessor.calculate_z_profiles
        '''
        result = utils.to_jsonable(result)
        row = models.MicroscopyFOVResult(
            fov_id=self.fov_id, kind='z-profiles', data=result
        )
        utils.add_and_commit(session, row, errors=self.errors)


    def insert_clean_tiff_metadata(self, session, result):
        '''
        Insert result from the generate_clean_tiff method
        '''
        result = utils.to_jsonable(result)
        row = models.MicroscopyFOVResult(
            fov_id=self.fov_id, kind='clean-tiff-metadata', data=result
        )
        utils.add_and_commit(session, row, errors=self.errors)


    def insert_corner_rois(self, session, result):
        '''
        Insert the four ROIs cropped from each corner of an FOV
        '''
        self._insert_rois(session, result, roi_kind='corner')


    def insert_annotated_roi(self, session, result):
        '''
        Insert the single manually-annotated ROI (if any)
        '''
        self._insert_rois(session, result, roi_kind='annotated')


    def _insert_rois(self, session, result, roi_kind):
        '''
        result : tuple of (error_info, roi_props) returned by FOVProcessor.crop_rois
        roi_kind : 'corner' or 'annotated'
        '''

        # FOVProcessor.crop_annotated_roi returns None if no manual annotation existed
        if result is None:
            return

        result, all_roi_props = result
        result = utils.to_jsonable(result)
        result_kind = '%s-roi-cropping' % roi_kind

        row = models.MicroscopyFOVResult(
            fov_id=self.fov_id, kind=result_kind, data=result
        )
        utils.add_and_commit(session, row, errors=self.errors)

        rois = []
        for roi_props in all_roi_props:
            roi_props = utils.to_jsonable(roi_props)
            roi = models.MicroscopyFOVROI(
                fov_id=self.fov_id, kind=roi_kind, props=roi_props
            )
            rois.append(roi)
        utils.add_and_commit(session, rois, errors=self.errors)
