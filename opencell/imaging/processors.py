import imageio
import logging
import numpy as np
import os
import skimage
import tifffile

from opencell.imaging import images, utils, nucleus_segmentation

logger = logging.getLogger(__name__)


class FOVProcessor:

    def __init__(
        self,
        parental_line_name,
        cell_line_id,
        fov_id,
        pml_id,
        plate_id,
        well_id,
        ensg_id,
        target_name,
        site_num,
        src_type,
        raw_filepath,
        all_roi_rows
    ):

        self.parental_line_name = parental_line_name
        self.cell_line_id = cell_line_id
        self.fov_id = fov_id
        self.pml_id = pml_id
        self.plate_id = plate_id
        self.well_id = well_id
        self.ensg_id = ensg_id
        self.target_name = target_name
        self.site_num = site_num

        # the root directory type
        # (either 'plate_microscopy' or 'raw_pipeline_microscopy')
        self.src_type = src_type

        # see set_src_roots
        self.src_roots = {}

        # the path to the destination 'opencell-microscopy' directory
        self.dst_root = None

        # the path to the raw TIFF, relative to src_root
        self.raw_filepath = raw_filepath

        # array of dicts for all ROIs cropped from the FOV
        self.all_roi_rows = all_roi_rows

        # create site_id from site_num
        self.site_id = 'S%02d' % int(self.site_num)


    def set_paths(
        self, plate_microscopy_dir=None, raw_pipeline_microscopy_dir=None, dst_root_dir=None
    ):
        '''
        Set the absolute paths to the 'PlateMicroscopy'
        and 'raw-pipeline-microscopy' directories

        On ESS, these should be
        '/gpfsML/ML_group/PlateMicroscopy/'
        '/gpfsML/ML_group/raw-pipeline-microscopy/'
        '''
        self.src_roots = {
            'plate_microscopy': plate_microscopy_dir,
            'raw_pipeline_microscopy': raw_pipeline_microscopy_dir
        }
        if dst_root_dir is not None:
            self.dst_root = dst_root_dir


    @classmethod
    def from_database(cls, fov):
        '''
        Initialize a processor given a microscopy_fov instance from opencelldb

        Note that this method assumes that fov.cell_line is an 'original' polyclonal line
        (and not, for example, a descendent generated by re-sorting an original polyclonal line
        or a clonal descendent of a polyclonal line)
        '''

        crispr_design = fov.cell_line.crispr_design

        # roi_props for all ROIs cropped from this FOV (will often be empty)
        all_roi_rows = [roi.as_dict() for roi in fov.rois]

        # get the name of the progenitor cell line
        line = fov.cell_line
        while True:
            line = line.parent
            if line.line_type.value == 'PROGENITOR':
                parental_line_name = line.name
                break

        processor = cls(
            parental_line_name=parental_line_name,
            cell_line_id=fov.cell_line.id,
            plate_id=crispr_design.plate_design_id,
            well_id=crispr_design.well_id,
            target_name=crispr_design.target_name,
            ensg_id=crispr_design.ensg_id,
            pml_id=fov.dataset.pml_id,
            fov_id=fov.id,
            site_num=fov.site_num,
            src_type=fov.dataset.root_directory,
            raw_filepath=fov.raw_filename,
            all_roi_rows=all_roi_rows
        )
        processor.fov = fov
        return processor


    @staticmethod
    def z_step_size(pml_id):
        '''
        Unpleasant method to determine the z-step size from the PML ID

        This method encodes the facts that, prior to ML0123 (aka PML0123),
        the step size was always 0.5um, and that starting at ML0123,
        the step size has always been 0.2um.

        NOTE: this method is necessary because the z-step size is *not* encoded
        in the MicroManager metadata or anywhere else
        '''
        z_step_size = 0.2
        critical_pml_num = 123
        pml_num = int(pml_id[3:])
        if pml_num < critical_pml_num:
            z_step_size = 0.5
        return z_step_size


    def src_filepath(self):
        '''
        Construct the absolute filepath to a TIFF stack
        in either the 'PlateMicroscopy' or 'raw-pipeline-microscopy' directory
        '''

        src_root = self.src_roots.get(self.src_type) or ''
        src_filepath = os.path.join(src_root, self.raw_filepath)
        return src_filepath


    def dst_plate_dir(self):
        '''
        Construct a dst plate_dir from an src plate_dir

        Destination plate directory names are of the form 'czML0383-P0001'
        '''
        dst_plate_dir = f'{self.parental_line_name}-{self.plate_id}'
        return dst_plate_dir


    def dst_filepath(
        self,
        kind=None,
        channel=None,
        roi_id=None,
        roi_props=None,
        roi_kind=None,
        ext=None,
        makedirs=True
    ):
        '''
        Construct the relative directory path and filename for an output file

        Directory path and filename formats:

        dst_filepath:   '{kind}/{dst_plate_dir}/{dst_filename}'
        dst_plate_dir:  'czML0383-{plate_id}'
        dst_filename:   'czML0383-{plate_id}-{well_id}-{pml_id}-S{site_num}_{appendix}'

        Appendix formats are kind-dependent:

        kind          appendix format
        -----------------------------------------------------------------
        'proj'        'PROJ-CH{channel}'
        'clean'       'CLEAN'
        'roi'         'ROI-{roi_kind}-{top_left_row}-{top_left_col}-{n_rows}-{n_cols}-CH{channel}'

        roi_kind is one of 'proj', 'hqtile', 'lqtile'

        Note that 'czML0383' is technically the name of the FOV's cell line's parental line,
        but for opencell datasets, this is always 'czML0383'.

        Here is a full example filename, for an 'roi' file:
        'czML00383-P0001-A01-PML0123-S01_ROI-HQTILE-0424-0000-0600-0600-CH405'
        '''

        kinds = ['proj', 'roi', 'clean', 'segmentation']
        if kind not in kinds:
            raise ValueError('%s is not a valid destination kind' % kind)

        # retrieve the roi_props if an roi_id was provided
        if roi_id is not None:
            row = [row for row in self.all_roi_rows if row['id'] == roi_id]
            if not row:
                raise ValueError('ROI %s is not an ROI of FOV %s' % (roi_id, self.fov_id))
            roi_props = row[0]['props']

        # construct the filename appendix, starting from `kind`
        appendix = kind.upper()

        # append the ROI coords, which we assume correspond to
        # (top_left_row, top_left_col, num_rows, num_cols)
        if kind == 'roi':
            for coord in roi_props['xy_coords']:
                appendix = '%s-%04d' % (appendix, coord)
            appendix = '%s-%s' % (appendix, roi_kind.upper())

        # append the channel last, so that when sorting files,
        # the two channels of each kind of file remain adjacent to one another
        if channel is not None:
            appendix = '%s-CH%s' % (appendix, channel)

        # destination plate_dir name
        dst_plate_dir = self.dst_plate_dir()

        # construct the destination dirpath
        dst_dirpath = os.path.join(self.dst_root or '', kind, dst_plate_dir)
        if self.dst_root is not None and makedirs:
            os.makedirs(dst_dirpath, exist_ok=True)

        # construct the destination filename
        dst_filename = (
            f'{dst_plate_dir}-{self.well_id}-{self.pml_id}-{self.site_id}_{appendix}.{ext}'
        )
        return os.path.join(dst_dirpath, dst_filename)


    def public_dst_filepath(self, kind):
        '''
        Construct the relative path to the raw z-stacks and z-projections for the annotated ROIs.
        These are TIFF files that are intended to be made public via an ODP S3 bucket,
        and are consequently organized into subdirectories by target, not plate.

        Example:
        {self.dst_root}/public/ATL2_ENSG00000119787/
            OC-FOV_ATL2_ENSG00000119787_CID000366_FID00038883_proj.tif
            OC-FOV_ATL2_ENSG00000119787_CID000366_FID00038883_stack.tif

        Notes:
        - the target_name appears before the ensg_id to allow sorting the subdirectories
          in a meaningful way.
        - the 'CID' and 'FID' stand for cell_line_id and fov_id, respectively.
        - the crispr_design is implicitly determined by the cell_line_id (and not by the ensg_id).
        - this filename schema, because it is public, ignores the distinction between FOVs and ROIs,
          and assumes that there will only ever be one ROI for each FOV.
        - an underscore, and not a dash, is used to separate fields in the filename
          because a few gene names contain a dash (e.g., 'H1-0')

        kind : 'stack' (for the full raw z-stack) or 'proj' (for the z-projection of the raw stack)
        '''
        if kind not in ['stack', 'proj']:
            raise ValueError("`kind` must be one of 'stack' or 'proj'")

        sep = '_'
        subdirname = 'public'
        target_dirname = f'{self.target_name}{sep}{self.ensg_id}'
        dst_dirpath = os.path.join(self.dst_root or '', subdirname, target_dirname)

        if self.dst_root:
            os.makedirs(dst_dirpath, exist_ok=True)

        dst_filename = sep.join([
            'OC-FOV',
            target_dirname,
            f'CID{self.cell_line_id:06d}',
            f'FID{self.fov_id:08d}',
            f'{kind}.tif'
        ])
        return os.path.join(dst_dirpath, dst_filename)


    def load_raw_tiff(self):
        '''
        Convenience method to open and parse a raw TIFF and attempt to split it by channel
        Returns None if the file does not exist or cannot be split by channel
        '''
        src_filepath = self.src_filepath()
        if os.path.isfile(src_filepath):
            tiff = images.RawPipelineTIFF(src_filepath, verbose=False)
            tiff.parse_micromanager_metadata()
            tiff.validate_micromanager_metadata()
            tiff.split_channels()
            if tiff.did_split_channels:
                return tiff
            else:
                logger.warning('Could not split the TIFF file at %s' % src_filepath)
                tiff.tiff.close()


    def process_raw_tiff(self):
        '''
        Process a single raw TIFF
            1) parse the micromanager and other metadata
            2) split the tiff pages into the z-stacks for the 405 and 488 channels
            3) generate z-projections

        NOTE: the `tiff.global_metadata` object returned by this method
        is modified by all of the `RawPipelineTIFF` methods called below
        (including by `project_stack`, which appends the min/max intensities)
        '''
        src_filepath = self.src_filepath()
        metadata = {'src_filepath': src_filepath}
        if not os.path.isfile(src_filepath):
            metadata['error'] = 'File does not exist'

        tiff = images.RawPipelineTIFF(src_filepath, verbose=False)
        tiff.parse_micromanager_metadata()
        tiff.validate_micromanager_metadata()

        # attempt to split the channels and project
        tiff.split_channels()
        if tiff.did_split_channels:
            for channel in [tiff.laser_405, tiff.laser_488]:
                dst_filepath = self.dst_filepath(kind='proj', channel=channel, ext='tif')
                tiff.project_stack(channel_name=channel, axis='z', dst_filepath=dst_filepath)

        # the tiff file must be manually closed
        tiff.tiff.close()

        metadata.update(tiff.global_metadata)

        # return the parsed raw TIFF metadata and the parsing events (if any)
        result = {'metadata': metadata, 'events': tiff.events}
        return result


    def calculate_fov_features(self, fov_scorer):
        '''
        Calculate the features and score for the FOV
        using the PipelineFOVScorer module from the dragonfly-automation project

        fov_scorer : an instance of PipelineFOVScorer in 'training' mode
        '''
        # construct the filepath to the z-projection of the Hoechst staining
        filepath = self.dst_filepath(kind='proj', channel='405', ext='tif')
        result = fov_scorer.process_existing_fov(filepath)
        return result


    @staticmethod
    def generate_thumbnail(im, scale, quality):
        '''
        '''
        # use downscale_local_mean to reduce noise
        im = skimage.transform.downscale_local_mean(im, factors=(scale, scale, 1))

        # crop the last row and column to eliminate edge effects
        im = im[:-1, :-1, :]

        # cast to uint8 again (downscale_local_mean outputs float64)
        im = utils.autoscale(im)

        # base64 encode
        encoded_image = utils.b64encode_image(im, format='jpg', quality=quality)
        return encoded_image


    def generate_fov_thumbnails(self, scale, quality):
        '''
        Generate thumbnail images of the z-projections as base64-encoded JPGs
        '''
        filepath_405 = self.dst_filepath(kind='proj', channel='405', ext='tif')
        filepath_488 = self.dst_filepath(kind='proj', channel='488', ext='tif')

        ims = {}
        ims['405'] = tifffile.imread(filepath_405)[..., None]
        ims['488'] = tifffile.imread(filepath_488)[..., None]
        ims['rgb'] = self.make_rgb(ims['405'], ims['488'])

        encoded_thumbnails = {}
        for channel, im in ims.items():
            encoded_thumbnails[channel] = self.generate_thumbnail(im, scale, quality)

        result = {
            'size': im.shape[0],
            'quality': quality,
            'encoded_thumbnails': encoded_thumbnails,
        }
        return result


    def generate_nucleus_segmentation(self):
        '''
        Generate nucleus segmentation mask from the z-projection of the 405 channel
        '''
        filepath = self.dst_filepath(kind='proj', channel='405', ext='tif')
        im = tifffile.imread(filepath)
        mask = nucleus_segmentation.generate_final_mask(im)

        result = None
        dst_filepath = self.dst_filepath(kind='segmentation', ext='tif')
        tifffile.imsave(dst_filepath, (255*mask).astype('uint8'), dtype='uint8')
        return result


    def generate_annotated_roi_thumbnails(self, scale, quality):
        '''
        Generate thumbnail images of the annotated ROI for the FOV (if any)
        '''

        # check that the FOV is annotated
        if not self.fov.annotation:
            return None

        # hack: check that an annotated ROI exists, and get the roi_id,
        # by using the fact that the only ROIs that exist are annotated ROIs
        # (some annotated FOVs may not have an ROI, if they could not be cropped in z)
        if not self.fov.rois:
            return None
        roi_id = self.fov.rois[0].id

        roi_size = 600
        top, left = self.fov.annotation.roi_position_top, self.fov.annotation.roi_position_left

        filepath_405 = self.dst_filepath(kind='proj', channel='405', ext='tif')
        filepath_488 = self.dst_filepath(kind='proj', channel='488', ext='tif')

        ims = {}
        ims['405'] = (
            tifffile.imread(filepath_405)
            [top:(top + roi_size), left:(left + roi_size), None]
        )
        ims['488'] = (
            tifffile.imread(filepath_488)
            [top:(top + roi_size), left:(left + roi_size), None]
        )
        ims['rgb'] = self.make_rgb(ims['405'], ims['488'])

        encoded_thumbnails = {}
        for channel, im in ims.items():
            encoded_thumbnails[channel] = self.generate_thumbnail(im, scale, quality)

        result = {
            'roi_id': roi_id,
            'size': im.shape[0],
            'quality': quality,
            'encoded_thumbnails': encoded_thumbnails,
        }
        return result


    def calculate_z_profiles(self):
        '''
        '''
        # attempt to load and split the TIFF
        result = {}
        tiff = self.load_raw_tiff()
        if tiff is None:
            result['error'] = 'Raw TIFF file for fov %s does not exist' % self.fov_id
            return result

        for channel in (tiff.laser_405, tiff.laser_488):
            try:
                result[channel] = tiff.calculate_z_profiles(tiff.stacks[channel])
            except Exception as error:
                result[channel] = {'error': str(error)}
        return result


    def generate_clean_tiff(self):
        '''
        Generate 'clean' but otherwise raw TIFFs for machine-learning pipelines by
            1) aligning the two channels to approximately correct for chromatic aberration in z
            2) centering and cropping the stacks around the cell layer in z
            3) downsampling stacks with 0.2um z-steps to 0.5um z-steps
        '''

        # the z-position of the top and bottom of the cell layer,
        # relative to the cell layer center, in microns
        cell_layer_bottom = -5
        cell_layer_top = 6

        # the desired step size of the clean TIFFs in um
        target_step_size = 0.5

        result = {}
        tiff = self.load_raw_tiff()
        if tiff is None:
            result['error'] = 'Raw TIFF file for fov %s does not exist' % self.fov_id
            return result

        step_size = self.z_step_size(self.pml_id)
        try:
            stacks, result = tiff.align_cell_layer(cell_layer_bottom, cell_layer_top, step_size)
        except Exception as error:
            result['error'] = str(error)

        # check if an error occurred above or in crop_and_align_cell_layer
        if result.get('error'):
            return result

        # if the step_size is 0.2um, downsample to 0.5um
        # (assumes that step_size is only ever 0.2um or 0.5um)
        if step_size == 0.2:
            zscale = step_size/target_step_size
            for channel in stacks:
                stacks[channel] = skimage.transform.rescale(
                    stacks[channel],
                    scale=(zscale, 1, 1),
                    multichannel=False,
                    preserve_range=True,
                    anti_aliasing=False,
                    order=1
                )
                stacks[channel] = stacks[channel].astype('uint16')

        # save the stacks as a hyperstack in CZXY order
        stack = np.concatenate((stacks['405'][None, :], stacks['488'][None, :]), axis=0)
        dst_filepath = self.dst_filepath(kind='clean', ext='tif')
        tifffile.imsave(dst_filepath, stack, dtype='uint16')

        result['final_stack_shape'] = stack.shape
        return result


    def crop_corner_rois(self):
        '''
        '''
        fov_size = 1024
        roi_size = 600
        min_coord = 0
        max_coord = fov_size - roi_size
        roi_top_left_positions = [
            (min_coord, min_coord),
            (min_coord, max_coord),
            (max_coord, min_coord),
            (max_coord, max_coord),
        ]
        return self._crop_rois(roi_size, roi_top_left_positions)


    def crop_annotated_roi(self):
        '''
        Crop the manually annotated ROI (assumes an annotation exists)
        '''

        # if no annotation exists or the annotated ROI coordinates are not defined
        if (
            not self.fov.annotation
            or self.fov.annotation.roi_position_top is None
            or self.fov.annotation.roi_position_left is None
        ):
            return None

        roi_size = 600
        roi_top_left_positions = [
            (
                self.fov.annotation.roi_position_top,
                self.fov.annotation.roi_position_left,
            )
        ]
        return self._crop_rois(roi_size, roi_top_left_positions)


    def _crop_rois(self, roi_size, roi_top_left_positions):
        '''
        Crop one or more ROIs from the cell-layer-cropped z-stacks,
        downsample the intensities from uint16 to uint8, and save each ROI as a tiled PNG

        Arguments
        ---------
        roi_size : the size of the ROI to crop (usually 600x600)
        roi_top_left_positions : the position of the top left corner of each ROI
            (as a list of (row, column) tuples)

        Returns
        -------
        error_info : a dict with an 'error' key if an error occured
        all_roi_props : a list of ROI properties (empty if an error ocurred)

        '''
        result = {}
        all_roi_props = []

        # attempt to load and split the TIFF
        raw_tiff = self.load_raw_tiff()
        if raw_tiff is None:
            result['error'] = 'Raw TIFF file for fov %s could not be loaded' % self.fov_id
            return result, all_roi_props

        # the top and bottom of the cell layer, relative to its center, in microns
        # (these were empirically determined)
        cell_layer_bottom = -5
        cell_layer_top = 6

        # wiggle room for the cell layer bottom (in microns)
        bottom_wiggle_room = 1

        # the desired step size of the final stack in microns
        # (this is chosen to correspond to the xy pixel size,
        # so that the voxels of the resampled stack will be isotropic)
        target_step_size = 0.4

        # the step size of the raw data
        original_step_size = self.z_step_size(self.pml_id)

        # the number of slices the resampled stack must have
        # this should be equal to, or rounded down from, (rel_top - rel_buttom) / target_step_size
        required_num_slices = 27

        # crop (and maybe pad) around the cell layer in z
        aligned_stacks, alignment_result = raw_tiff.align_cell_layer(
            cell_layer_bottom,
            cell_layer_top,
            step_size=original_step_size,
            bottom_wiggle_room=bottom_wiggle_room
        )

        result['cell_layer_top'] = cell_layer_top
        result['cell_layer_bottom'] = cell_layer_bottom
        result['bottom_wiggle_room'] = bottom_wiggle_room
        result['alignment_result'] = alignment_result

        # if an alignment error occured, log it and do not continue
        # (these errors occur when the cell layer center was too close
        # to the top or bottom of the z-stack)
        if alignment_result.get('error'):
            result['error'] = 'An error ocurred in align_cell_layer'
            return result, all_roi_props

        # for now, the ROIs span the full extent of the cell-layer-cropped stack
        min_z_ind = 0
        max_z_ind = aligned_stacks['405'].shape[0]

        # the shape of each ROI
        roi_shape = (roi_size, roi_size, max_z_ind - min_z_ind)

        # append the z-position to the ROI positions
        roi_top_left_positions = [(*pos, min_z_ind) for pos in roi_top_left_positions]

        for roi_position in roi_top_left_positions:
            roi_props = {
                'shape': roi_shape,
                'position': roi_position,
                'xy_coords': (*roi_position[:2], *roi_shape[:2]),
                'target_step_size': target_step_size,
                'original_step_size': original_step_size,
                'required_num_slices': required_num_slices,
            }
            # crop the ROI
            cropped_stacks, cropped_raw_stacks, roi_props = self._crop_roi(
                roi_props, aligned_stacks, raw_tiff
            )
            # save the ROI
            roi_props = self._save_roi(cropped_stacks, cropped_raw_stacks, roi_props)

            all_roi_props.append(roi_props)

        return result, all_roi_props


    def _crop_roi(self, roi_props, aligned_stacks, raw_tiff):
        '''
        Crop an ROI from the raw TIFF, resample it in z if necessary,
        and downsample it from uint16 to uint8
        '''

        num_rows, num_cols, num_z = roi_props['shape']
        row_ind, col_ind, z_ind = roi_props['position']

        cropped_stacks = {}
        cropped_raw_stacks = {}
        for channel in ['405', '488']:

            # crop the ROI from the raw aligned stack
            cropped_stack = aligned_stacks[channel][
                z_ind:(z_ind + num_z),
                row_ind:(row_ind + num_rows),
                col_ind:(col_ind + num_cols)
            ]

            # crop the ROI from original, unaligned raw stack
            cropped_raw_stacks[channel] = raw_tiff.stacks[channel][
                :, row_ind:(row_ind + num_rows), col_ind:(col_ind + num_cols)
            ]

            # move the z dimension from the first to the last axis
            cropped_stack = np.moveaxis(cropped_stack.copy(), 0, -1)

            # resample the stack in z so it has the required step size and number of z-slices
            cropped_stack, did_resample_stack = self.maybe_resample_stack(
                cropped_stack,
                original_step_size=roi_props['original_step_size'],
                target_step_size=roi_props['target_step_size'],
                required_num_slices=roi_props['required_num_slices']
            )

            # the did_resample_stack flag will always be the same for both channels
            roi_props['stacks_resampled'] = did_resample_stack

            # downsample the pixel intensities from uint16 to uint8
            cropped_stack, min_intensity, max_intensity = self.stack_to_uint8(
                cropped_stack, percentile=0.01
            )

            # log the black and white points used to downsample the intensities
            roi_props['min_intensity_%s' % channel] = min_intensity
            roi_props['max_intensity_%s' % channel] = max_intensity

            # smooth the hoechst channel slightly to reduce the tiled JPG filesize
            if channel == '405':
                cropped_stack = skimage.filters.gaussian(
                    cropped_stack, sigma=(.5, .5, .5), preserve_range=True
                )
                cropped_stack = cropped_stack.astype('uint8')

            cropped_stacks[channel] = cropped_stack
        return cropped_stacks, cropped_raw_stacks, roi_props


    def _save_roi(self, stacks, raw_stacks, roi_props):
        '''
        Export the image data for an ROI generated by _crop_roi in several forms:
        - the full raw z-stack, as an imageJ TIFF
        - the raw z-projection, as an imageJ TIFF
        - the z-projection of the z-cropped z-stack, as a JPEG
        - a 2D tiled array of the z-slices from the z-cropped z-stack, as JPEG

        Notes:
        - the raw TIFFs are intended for public consumption via an ODP S3 bucket,
          but the JPEGs are intended for consumption only by the frontend
          (see the opencell.api.resources.MicroscopyFOVROI endpoint)
        - for the JPEG tiles, this method uses hand-picked optimizations
          to minimize filesizes that are specific to uint8 ROIs of shape (600, 600, 27)
          (or something close to that)
        '''

        # the `compression` kwarg of tifffile.imsave is not supported by older versions of tifffile,
        # including the most recent version available on ESS, but ideally we would use it,
        # because empirically it reduces filesizes by 10-20%
        use_compression = False
        imsave_kwargs = dict(compression='DEFLATE') if use_compression else dict()

        raw_stack = np.concatenate(
            (raw_stacks['405'][None, :], raw_stacks['488'][None, :]), axis=0
        )
        # move the z-axis to the first dimension of the raw stack
        # (because ImageJ hyperstacks must be in ZCYX order)
        raw_stack = np.moveaxis(raw_stack, 1, 0)

        # pixel size of the raw images in microns
        pixel_size = 0.2
        z_step_size = roi_props['original_step_size']

        # save the raw z-stack as a TIFF file in ImageJ hyperstack format
        # (following an example from the tifffile docs)
        tifffile.imsave(
            self.public_dst_filepath(kind='stack'),
            data=raw_stack,
            dtype='uint16',
            imagej=True,
            resolution=(1/pixel_size, 1/pixel_size),
            metadata={'spacing': z_step_size, 'unit': 'um', 'axes': 'ZCYX'},
            **imsave_kwargs
        )

        # save the raw z-projection as a TIFF
        raw_proj = raw_stack.max(axis=0)
        tifffile.imsave(
            self.public_dst_filepath(kind='proj'),
            data=raw_proj,
            dtype='uint16',
            imagej=True,
            resolution=(1/pixel_size, 1/pixel_size),
            metadata={'unit': 'um', 'axes': 'CYX'},
            **imsave_kwargs
        )

        # common args for the dst_filepath method for tiled JPGs
        common_kwargs = dict(kind='roi', roi_props=roi_props, ext='jpg')

        # save the z-stacks and z-projections as (tiled) JPEGs
        tiles = {}
        for channel in stacks.keys():

            # save the z-projection
            proj = stacks[channel].max(axis=-1)
            dst_filepath = self.dst_filepath(roi_kind='proj', channel=channel, **common_kwargs)
            imageio.imsave(dst_filepath, proj, format='jpg', quality=95)

            # reshape the ROI stacks into a one-dimensional tiled array of z-slices
            stack = np.moveaxis(stacks[channel], -1, 0)
            tiles[channel] = np.concatenate([zslice for zslice in stack], axis=0)

        # for high-quality hoechst, use a fixed JPG quality of 90%
        channel = '405'
        jpg_quality = 90
        dst_filepath = self.dst_filepath(roi_kind='hqtile', channel=channel, **common_kwargs)
        imageio.imsave(dst_filepath, tiles[channel], format='jpg', quality=jpg_quality)
        roi_props['high_jpg_quality_%s' % channel] = jpg_quality

        # for low-quality hoechst, use a fixed JPG quality of 50%
        jpg_quality = 50
        dst_filepath = self.dst_filepath(roi_kind='lqtile', channel=channel, **common_kwargs)
        imageio.imsave(dst_filepath, tiles[channel], format='jpg', quality=jpg_quality)
        roi_props['low_jpg_quality_%s' % channel] = jpg_quality

        # for high-quality GFP, use the JPG quality that yields a filesize less than 4MB
        channel = '488'
        target_filesize = 4.0
        dst_filepath = self.dst_filepath(roi_kind='hqtile', channel=channel, **common_kwargs)
        jpg_quality = self.save_jpg(
            dst_filepath, tiles[channel], target_filesize, min_quality=70, max_quality=95
        )
        roi_props['high_jpg_quality_%s' % channel] = jpg_quality

        # for low-quality GFP, use the JPG quality that yields a filesize less than 1MB
        target_filesize = 1.0
        dst_filepath = self.dst_filepath(roi_kind='lqtile', channel=channel, **common_kwargs)
        jpg_quality = self.save_jpg(
            dst_filepath, tiles[channel], target_filesize, min_quality=30, max_quality=90
        )
        roi_props['low_jpg_quality_%s' % channel] = jpg_quality

        return roi_props


    @staticmethod
    def save_jpg(filepath, image, target_filesize, min_quality, max_quality):
        '''
        Save a JPG with a quality chosen to match a target filesize
        Note: this is a hackish implementation

        image : numpy array (assumed to be JPG-compatible)
        target_filesize : the desired filesize, in megabytes
        min_quality, max_quality : hard-coded bounds on the JPG quality
        '''
        jpg_qualities = range(max_quality, min_quality, -5)
        for jpg_quality in jpg_qualities:
            imageio.imsave(filepath, image, format='jpg', quality=jpg_quality)
            if os.stat(filepath).st_size/1024/1024 < target_filesize:
                break
        return jpg_quality


    @staticmethod
    def maybe_resample_stack(stack, original_step_size, target_step_size, required_num_slices):
        '''
        Resample and possibly crop or pad a z-stack
        so that it has the required number of z-slices

        stack : 3D numpy array with dimensions (x, y, z)
        original_step_size : the z-step size of the original stack (in microns)
        target_step_size : the desired z-step size after resampling (in microns)
        required_num_slices : the number of z-slices the resampled stack must have
        '''

        did_resample_stack = False

        # resample z to generate isotropic voxels
        if original_step_size != target_step_size:
            did_resample_stack = True
            z_scale = original_step_size/target_step_size
            stack = skimage.transform.rescale(
                stack,
                (1, 1, z_scale),
                multichannel=False,
                preserve_range=True,
                anti_aliasing=False,
                mode='reflect',
                order=1
            )

        # pad or crop z-slices from the end (top) of the z-stack
        # so that the stack has the required number of slices
        num_rows, num_cols, num_slices = stack.shape
        if num_slices < required_num_slices:
            pad = np.zeros(
                (num_rows, num_cols, required_num_slices - num_slices),
                dtype=stack.dtype
            )
            stack = np.concatenate((stack, pad), axis=2)
        elif num_slices > required_num_slices:
            stack = stack[:, :, :required_num_slices]

        return stack, did_resample_stack


    @staticmethod
    def stack_to_uint8(stack, percentile):
        '''
        Downsample the raw uint16 pixel intensities to uint8
        and return the black and white points used to do so
        '''

        stack = stack.astype(float)
        minn, maxx = np.percentile(stack, (percentile, 100 - percentile))
        if minn == maxx:
            maxx = minn + 1

        stack -= minn
        stack[stack < 0] = 0
        stack /= (maxx - minn)
        stack[stack > 1] = 1

        stack = (255*stack).astype('uint8')
        return stack, int(minn), int(maxx)


    @staticmethod
    def stack_to_tile2d(stack, num_cols):
        '''
        Transform a z-stack into a 2D array of z-slices
        (currently unused)

        stack : 3D numpy array with dimensions (x, y, z)
        num_cols : the number of columns in the tile
        '''

        num_slices = stack.shape[-1]
        num_extra_slices = int(num_cols * np.ceil(num_slices/num_cols) - num_slices)
        extra_slices = np.zeros((*stack.shape[:2], num_extra_slices), dtype=stack.dtype)
        stack = np.concatenate((stack, extra_slices), axis=2)

        num_slices = stack.shape[-1]
        num_rows = int(num_slices/num_cols)

        rows = []
        for row_ind in range(num_rows):
            row = np.concatenate(
                [stack[:, :, col_ind + row_ind*num_cols] for col_ind in range(num_cols)], axis=1
            )
            rows.append(row)
        tile = np.concatenate(rows, axis=0)

        return tile


    @staticmethod
    def make_rgb(im_405, im_488):
        '''
        Construct an RGB image from z-projections (or single z-slices) of each channel
        im_405 : 2D numpy array (assumed to be the Hoechst staining)
        im_488 : 2D numpy array (assumed to be the GFP signal)
        '''

        if im_405.ndim == 2:
            im_405 = im_405[..., None]
        if im_488.ndim == 2:
            im_488 = im_488[..., None]

        # background subtract the hoechst
        im_405 = im_405.astype(float)
        im_405 -= im_405.mean()
        im_405[im_405 < 0] = 0

        # downscale to uint8 using 1% percentiles
        # (and bump the gamma for hoechst to make it stand out again the GFP a bit better)
        hoechst = utils.autoscale(im_405, percentile=1, gamma=.7)
        gfp = utils.autoscale(im_488, percentile=1)

        # set the blue channel to the maximum of the GFP and hoechst
        # (this is easier than summing the channels and dealing with uint8 overflow, etc)
        blue = np.concatenate((gfp, hoechst), axis=2).max(axis=2)[..., None]

        red, green = gfp, gfp
        rgb = np.concatenate((red, green, blue), axis=2)
        return rgb
